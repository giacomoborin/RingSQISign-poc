from setup import p, O0, logp, loglogp, Dc, T, l, e
from KLPT import derive_L, RepresentIntegerHeuristic, derive_L2_SigningKLPT
from ideals import left_isomorphism, pullback_ideal, equivalent_left_ideals
from sage.all import floor, log, is_square, IntegerModRing

def distinguisher(JJ, Iτ, e = e):
    """
    A simple probabilistic distinguisher between ideals
    random ideals from the one generated by SigningKLPT,
    given the secret key Itau

    Input:
        JJ: ideal of norm l**e
        Iτ: secret connecting ideal
    Output:
        if True return NL (norm of L) and gamma used in KLPT
        else return None
    """
    # JJ is an O1 ideal of norm 2^*
    # Iτ is the secret ideal

    # preparation
    O0 = Iτ.left_order()
    O1 = Iτ.right_order()
    Nτ = Iτ.norm()

    assert O1 == JJ.left_order(), 'input ideal defined on the wrong order'

    prime_ideal_try = 10
    gamma_try = 1000
    for _ in range(prime_ideal_try):
        # derivation of the prime norm ideal, expected <5 trial
        L,NL,_ = derive_L(JJ, Iτ, Nτ, O0, O1)

        # recalculation of e1 from N
        e1 = floor(logp - log(NL, l) + 1.74 * loglogp)
        L1 = l**e1

        # recalculation of possible betas, we may need the scaling
        # scaling = 2 # in [1..32]
        JJprime = pullback_ideal(O0, O1, JJ, Iτ)
        if not equivalent_left_ideals(L,JJprime):
            continue
        beta = (left_isomorphism(L,JJprime) * NL).conjugate()
        repr_int = NL * L1
        for _ in range(gamma_try):
            gamma = RepresentIntegerHeuristic(repr_int)
            mu = gamma**-1 * beta
            # the factor 32*9*5*7 is beacuse of the possible
            # scaling of the ideal happened in KLPT 
            if 32*9*5*7*mu in O0:
                if 0 == mu[0] % (Nτ*NL) and 0 == mu[1] % (Nτ*NL):
                    L2 = derive_L2_SigningKLPT(gamma, L1, e1, e = e)
                    C, D = mu[2], mu[3]
                    if (is_square(IntegerModRing(Nτ*NL)(p*(C**2 + D**2)*L2))):
                        # here we do not go as far as cheching also the
                        # other conditions since the probability of passing
                        # these checks for a random endomorphism is already
                        # negligible since (NN_t)**-2 << 2**-lam
                        print('Generated by KLPT')
                        return NL,gamma
    print('Not generated by KLPT')
    return None
